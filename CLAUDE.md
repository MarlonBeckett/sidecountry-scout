# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Sidecountry Scout is an AI-powered backcountry avalanche safety companion that transforms complex avalanche forecasts into clear, actionable briefings. Built with Next.js 16, it combines real-time avalanche data from avalanche.org with Google Gemini AI to provide educational safety briefings for backcountry enthusiasts.

## Development Commands

```bash
# Development
npm run dev          # Start development server at http://localhost:3000

# Production
npm run build        # Build for production
npm start            # Start production server

# Linting
npm run lint         # Run ESLint
```

## Architecture & Data Flow

### Core Data Pipeline

The application follows a multi-source data aggregation pattern:

1. **Avalanche Forecasts** (`/api/forecasts`)
   - Fetches from avalanche.org Map-Layer API (zone discovery) + Product API (full forecast details)
   - Cached in Supabase `avalanche_forecasts` table for 1 hour
   - Provides zone geometry, danger levels, official discussions, and avalanche problems

2. **Weather Data** (`/api/weather`)
   - Fetches from Open-Meteo API based on zone centroid coordinates
   - Cached in Supabase `weather_data` table for 6 hours
   - Provides current conditions, hourly/daily forecasts, and wind/snow data

3. **AI Briefings** (`/api/briefings/generate`)
   - Generated by Google Gemini 2.5 Flash
   - Combines avalanche forecast + weather data + official field observations
   - Cached in Supabase `avalanche_briefings` table for 1 day per zone
   - Focuses on educational, beginner-friendly explanations

4. **Chat Feature** (`/api/chat`)
   - Real-time streaming AI responses using Gemini 2.0 Flash
   - Context-aware: has access to current briefing and forecast data
   - Not cached, generates responses on-demand

### Critical Implementation Details

**Caching Strategy**: Different data types have different cache durations based on update frequency. The caching logic is in each API route - when modifying cache behavior, update both the Supabase query AND the revalidate constant.

**AI Prompting**: The Gemini AI receives comprehensive context including official forecast discussions, current weather, and field observations. The prompt (in `/api/briefings/generate/route.ts`) is engineered to produce educational content with analogies and practical terrain advice. When modifying AI behavior, edit the system prompt, not the model parameters.

**Geometry Handling**: Zone geometries from avalanche.org are stored as GeoJSON in the database. Weather API coordinates are calculated from the centroid of these polygons (see weather route for calculation logic).

**Authentication Flow**: Uses Supabase Auth with Row Level Security (RLS). User preferences are per-user and synced across sessions. The AuthContext provider wraps the app and provides user state globally.

## Project Structure

```
app/
├── api/
│   ├── forecasts/route.ts        # Avalanche.org data aggregation
│   ├── weather/route.ts          # Open-Meteo integration
│   ├── briefings/
│   │   ├── generate/route.ts     # AI briefing generation
│   │   ├── regenerate/route.ts   # Force regenerate cached briefing
│   │   └── route.ts              # Fetch cached briefing
│   ├── chat/route.ts             # Streaming chat with context
│   ├── chat-history/route.ts     # User chat history CRUD
│   └── preferences/route.ts      # User location preferences
├── auth/page.tsx                 # Sign up/sign in
├── chat/page.tsx                 # Chat history view
├── profile/page.tsx              # User profile
└── page.tsx                      # Main app (briefing display)

components/
├── ui/                           # shadcn/ui base components
├── location/                     # Location selection components
│   ├── LocationSelector.tsx
│   └── LocationSelectorSheet.tsx
├── navigation/                   # App navigation
│   ├── BottomNav.tsx
│   ├── DesktopSidebar.tsx
│   └── LayoutWrapper.tsx
├── weather/                      # Weather display
│   └── WeatherCard.tsx
├── chat/                         # Chat interface
│   └── ChatHistorySidebar.tsx
└── forecast/                     # Forecast display
    └── ForecastPhotoGallery.tsx

hooks/
├── useAvalancheForecasts.ts     # Fetch all forecasts
├── useBriefing.ts               # Fetch/generate briefing
└── useWeather.ts                # Fetch weather data

contexts/
└── AuthContext.tsx              # Supabase auth state

lib/
├── api/                          # External API clients
│   ├── avalanche-org.ts         # Avalanche.org client
│   ├── open-meteo.ts            # Weather API client
│   ├── gemini.ts                # Google Gemini AI client
│   └── index.ts
├── db/                           # Database utilities
│   ├── client.ts                # Supabase client configuration
│   ├── queries.ts               # Shared database queries
│   └── index.ts
├── utils/                        # Utility functions
│   ├── html.ts                  # HTML sanitization
│   ├── geometry.ts              # GeoJSON/coordinate utils
│   ├── date.ts                  # Date formatting/helpers
│   ├── center-mapping.ts        # Center name → ID mapping
│   └── index.ts
└── utils.ts                     # Tailwind cn() utility (legacy location)

types/
├── forecast.ts                   # Avalanche forecast types
├── briefing.ts                   # AI briefing types
├── weather.ts                    # Weather data types
├── database.ts                   # Supabase table types
├── api.ts                        # API response types
└── index.ts                      # Central type exports

constants/
├── avalanche.ts                  # Danger levels, problem types
├── cache.ts                      # Cache duration constants
├── api.ts                        # API endpoints & config
└── index.ts                      # Central constant exports
```

## Database Schema (Supabase)

**Key Tables**:
- `avalanche_forecasts` - Cached avalanche.org data with full forecast details
- `weather_data` - Cached Open-Meteo responses
- `avalanche_briefings` - AI-generated briefings (one per zone per day)
- `user_preferences` - User's selected center/zone with RLS policies
- `chat_history` - User chat messages (not currently active in main UI)

All tables use RLS. The service role key is required for API routes to bypass RLS when caching data. Client-side code uses the anon key with user-specific RLS policies.

## Environment Variables

Required in `.env.local`:

```bash
# Google Gemini API
google_gemini_api=your_api_key

# Supabase
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_anon_key
NEXT_SECRET_SERVICE_ROLE_KEY=your_service_role_key
```

## Key Technical Decisions

**Next.js App Router**: All routes use the App Router (not Pages Router). Server components are preferred where possible. API routes are in `app/api/` as Route Handlers.

**TypeScript Strictness**: Strict mode is enabled. All components and utilities should be fully typed. The `@/` path alias resolves to the project root.

**Styling System**: Uses Tailwind CSS v4 with shadcn/ui component library. Theme is controlled via CSS custom properties in `app/globals.css` (see THEME_GUIDE.md for hot-swapping themes). Dark mode is the default via `className="dark"` on the `<html>` element.

**AI Model Selection**:
- Briefing generation: Gemini 2.5 Flash (better instruction following, structured output)
- Chat: Gemini 2.0 Flash Experimental (faster streaming, conversational)

**Data Freshness**: Avalanche forecasts are typically published once daily by avalanche centers (usually morning). The 1-hour cache ensures we check for updates regularly without hammering the API. Weather updates more frequently (6-hour cache). Briefings are generated once per day per zone to save AI costs.

## Common Development Tasks

**Adding a new API endpoint**: Create a new `route.ts` in `app/api/your-endpoint/`. Use the Supabase service role client for database access that bypasses RLS. Return NextResponse with appropriate error handling.

**Modifying AI prompts**: Edit the prompt string in `/api/briefings/generate/route.ts`. The AI expects JSON output in a specific schema - maintain the output format. Test with multiple zones to ensure robustness.

**Adding new forecast data**: Avalanche.org APIs return extensive data. New fields can be extracted in `/api/forecasts/route.ts` and stored in the `forecast_avalanche_problems` or `media` JSONB columns. Update the TypeScript interfaces to match.

**Updating cache duration**: Modify the `revalidate` export constant in the API route AND the Supabase query's time interval check. Both must match for consistent behavior.

**Theme changes**: Modify HSL values in `app/globals.css` under `:root` or `.dark`. All UI components reference these CSS variables. Use tweakcn.com to generate cohesive color schemes.

## Module Organization

**Types** (`types/`): All TypeScript type definitions are centralized here. Import from `@/types` to get all types. Each module (forecast, briefing, weather, database, api) has its own file.

**Constants** (`constants/`): All magic numbers and strings live here. Import from `@/constants` for avalanche danger levels, cache durations, API endpoints, etc.

**API Clients** (`lib/api/`): Each external API has its own client class. These handle all HTTP requests and response transformations. Use singleton instances exported from each module.

**Database Queries** (`lib/db/queries.ts`): All shared database queries are defined here. Use these instead of writing raw Supabase queries in components or API routes.

**Utilities** (`lib/utils/`): Common utility functions organized by domain (html, geometry, date, etc.). Import from `@/lib/utils` for convenience.

**Components**: Organized by feature domain. Each feature gets its own directory under `components/`. The `ui/` directory contains only base shadcn/ui primitives.

## Important Files to Review

- `DATA_FLOW.md` - Complete documentation of data pipeline from API to UI
- `PRODUCT_DESCRIPTION.md` - Feature overview and use cases
- `THEME_GUIDE.md` - Theme customization instructions

## Testing Considerations

When testing:
1. Clear Supabase caches by manually deleting rows in tables for today's date
2. Test with multiple avalanche centers - not all return the same data structure
3. Verify RLS policies work by testing as different authenticated users
4. Check AI output quality with various danger levels and avalanche problems
5. Test responsive layout on both mobile (bottom nav) and desktop (sidebar)

## Integration Points

**Avalanche.org API**: No authentication required. Rate limits unknown - caching is critical. API may return incomplete data for some zones (check `hasFullForecast` flag).

**Open-Meteo API**: Free tier, no authentication. Returns imperial units (configured in query params). Centroid calculation for zone geometry happens in the weather API route.

**Google Gemini**: Requires API key. Uses JSON mode for structured output. Streaming is supported for chat but not briefing generation. Monitor quota usage.

**Supabase**: Authentication state is global via AuthContext. API routes use service role for caching, client uses anon key with RLS for user data.
